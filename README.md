<div align="center">

# MHGA

</div>

## ğŸ“‘ ëª©ì°¨

- [í”„ë¡œì íŠ¸ ê°œìš”](#-í”„ë¡œì íŠ¸-ê°œìš”)
- [í•µì‹¬ ì‹œìŠ¤í…œ êµ¬ì¡°](#-í•µì‹¬-ì‹œìŠ¤í…œ-êµ¬ì¡°)
  - [ë„¤íŠ¸ì›Œí¬ ì•„í‚¤í…ì²˜](#1-ë„¤íŠ¸ì›Œí¬-ì•„í‚¤í…ì²˜)
  - [AI ì†ë‹˜ ì‹œìŠ¤í…œ](#2-ai-ì†ë‹˜-ì‹œìŠ¤í…œ)
  - [ì¡°ë¦¬ ì‹œìŠ¤í…œ](#3-ì¡°ë¦¬-ì‹œìŠ¤í…œ)
  - [í¬ì¥ ë° ë ˆì‹œí”¼ ê²€ì¦](#4-í¬ì¥-ë°-ë ˆì‹œí”¼-ê²€ì¦-ì‹œìŠ¤í…œ)
  - [POS ì‹œìŠ¤í…œ](#5-pospoint-of-sale-ì‹œìŠ¤í…œ)
  - [ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ](#6-ìƒí˜¸ì‘ìš©-ì‹œìŠ¤í…œ)
  - [ìºë¦­í„° ë° ì…ë ¥](#7-ìºë¦­í„°-ë°-ì…ë ¥-ì‹œìŠ¤í…œ)
- [í¬íŠ¸í´ë¦¬ì˜¤ í•µì‹¬ í•­ëª©](#-í¬íŠ¸í´ë¦¬ì˜¤-í•µì‹¬-í•­ëª©)
- [ê¸°ìˆ ì  í•˜ì´ë¼ì´íŠ¸](#-ê¸°ìˆ ì -í•˜ì´ë¼ì´íŠ¸)
- [ê²Œì„ í”Œë¡œìš°](#-ê²Œì„-í”Œë¡œìš°-ë°-ì‹œë‚˜ë¦¬ì˜¤)
- [ê¸°ìˆ  ìŠ¤íƒ](#-ì‚¬ìš©-ê¸°ìˆ -ìŠ¤íƒ)
- [ì„±ëŠ¥ ìµœì í™”](#-ì„±ëŠ¥-ìµœì í™”)
- [í•™ìŠµ í¬ì¸íŠ¸](#-í•™ìŠµ-í¬ì¸íŠ¸-ë°-ë„ì „-ê³¼ì œ)
- [í–¥í›„ ê°œì„ ](#-í–¥í›„-ê°œì„ -ë°©í–¥)
- [ì½”ë“œ êµ¬ì¡°](#-ì½”ë“œ-êµ¬ì¡°)
- [í¬íŠ¸í´ë¦¬ì˜¤ ê°•ì¡° í¬ì¸íŠ¸](#-í¬íŠ¸í´ë¦¬ì˜¤-ê°•ì¡°-í¬ì¸íŠ¸)

---

## ğŸ“‹ í”„ë¡œì íŠ¸ ê°œìš”

**MHGA**ëŠ” ì‹¤ì œ í–„ë²„ê±° ê°€ê²Œì˜ ì•„ë¥´ë°”ì´íŠ¸ í™˜ê²½ì„ ì‹œë®¬ë ˆì´ì…˜í•œ í˜‘ë™ ê²Œì„ì…ë‹ˆë‹¤. í”Œë ˆì´ì–´ëŠ” ì†ë‹˜ ì£¼ë¬¸ ì ‘ìˆ˜ë¶€í„° ì¬ë£Œ ì¡°ë¦¬, í–„ë²„ê±° ì œì‘, ìŒì‹ ì „ë‹¬ê¹Œì§€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ê²½í—˜í•˜ë©°, ë™ë£Œë“¤ê³¼ í˜‘ë ¥í•˜ì—¬ ëª°ë ¤ë“œëŠ” ì†ë‹˜ë“¤ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ëŒ€í•´ì•¼ í•©ë‹ˆë‹¤.

### ê°œë°œ í™˜ê²½
- **ì—”ì§„**: Unreal Engine 5.6
- **ê°œë°œ ì–¸ì–´**: C++ / Blueprint
- **ë„¤íŠ¸ì›Œí¬**: Listen Server ê¸°ë°˜ ë©€í‹°í”Œë ˆì´
- **ê°œë°œ ì¸ì›**: 3ëª… (ê¹€í™ë²”, í™©ê·œí™˜, í—ˆì§€ì›…)

### í”„ë¡œì íŠ¸ ì»¨ì…‰ (README ê¸°ë°˜)
- **í–„ë²„ê±° ì•„ë¥´ë°”ì´íŠ¸ ì‹œë®¬ë ˆì´ì…˜**
- í–„ë²„ê±° ê°€ê²Œì˜ ì•„ë¥´ë°”ì´íŠ¸ë¥¼ ê³„ì‚°ë¶€í„° ìŒì‹ ì¡°ë¦¬ê¹Œì§€ ê²½í—˜
- ë™ë£Œë“¤ê³¼ í˜‘ì‹¬í•˜ì—¬ ì†ë‹˜ë“¤ì´ ëª°ë ¤ë“œëŠ” í–„ë²„ê±° ê°€ê²Œ ê²½ì˜ ëª¨ì˜ì‹¤í—˜
- ì‹¤ì œ ê·¼ë¬´ í™˜ê²½ê³¼ ë¹„ìŠ·í•œ í™˜ê²½ êµ¬ì„±
- ë ˆì‹œí”¼ëŠ” ë²½ì— ë¶™ì–´ìˆê±°ë‚˜ ì•”ê¸°í•´ì•¼ í•¨

### ì£¼ìš” íŠ¹ì§•
- âœ… **ë¦¬ìŠ¨ ì„œë²„ ê¸°ë°˜ ë©€í‹°í”Œë ˆì´**: í˜‘ë™ í”Œë ˆì´ ì§€ì›
- âœ… **AI ì†ë‹˜ ì‹œìŠ¤í…œ**: FSM ê¸°ë°˜ì˜ ì§€ëŠ¥í˜• ì†ë‹˜ í–‰ë™ íŒ¨í„´
- âœ… **ì‹¤ì œ ë ˆì‹œí”¼ ê¸°ë°˜ ì¡°ë¦¬ ì‹œìŠ¤í…œ**: ë°ì´í„° í…Œì´ë¸”ì„ í™œìš©í•œ ì •í™•í•œ ë©”ë‰´ êµ¬ì„±
- âœ… **ë¬¼ë¦¬ ê¸°ë°˜ ìƒí˜¸ì‘ìš©**: ì¬ë£Œ ì§‘ê¸°, ì¡°ë¦¬, í¬ì¥ ë“± ëª¨ë“  ì‘ì—…ì´ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ê¸°ë°˜
- âœ… **3D UI ì‹œìŠ¤í…œ**: Widget Interactionì„ í™œìš©í•œ POS ì‹œìŠ¤í…œ
- âœ… **ë™ì  ì†ë‹˜ ê´€ë¦¬**: ìµœëŒ€ ì†ë‹˜ ìˆ˜ ì œí•œ ë° ëŒ€ê¸°ì—´ ì‹œìŠ¤í…œ

---

## ğŸ® í•µì‹¬ ì‹œìŠ¤í…œ êµ¬ì¡°

### 1. ë„¤íŠ¸ì›Œí¬ ì•„í‚¤í…ì²˜

**ë¦¬ìŠ¨ ì„œë²„ êµ¬ì¡°ë¥¼ í†µí•œ íš¨ìœ¨ì ì¸ ë©€í‹°í”Œë ˆì´ êµ¬í˜„**

#### ë„¤íŠ¸ì›Œí¬ êµ¬ì¡° ë‹¤ì´ì–´ê·¸ë¨

```mermaid
graph TB
    subgraph "Listen Server"
        H["ğŸ® Host Player<br/>(Server Authority)"]
        GM["âš™ï¸ GameMode<br/>(Logic)"]
        GS["ğŸ“Š GameState<br/>(Replicate)"]
    end

    subgraph "Network"
        RPC["ğŸ”„ RPC í˜¸ì¶œ"]
        REP["ğŸ“¡ Replication"]
    end

    subgraph "Client 1"
        C1["ğŸ‘¤ Player 1<br/>(Local Control)"]
        UIC1["ğŸ¨ UI/Cache"]
    end

    subgraph "Client 2"
        C2["ğŸ‘¤ Player 2<br/>(Local Control)"]
        UIC2["ğŸ¨ UI/Cache"]
    end

    H -->|Authority| GM
    GM -->|Updates| GS
    GS -->|REP| REP
    C1 -->|RPC| RPC
    C2 -->|RPC| RPC
    RPC -->|ServerRPC| GM
    GM -->|MulticastRPC| RPC
    REP -->|Sync| UIC1
    REP -->|Sync| UIC2

    style H fill:#FFB6C6
    style GM fill:#87CEEB
    style GS fill:#98FB98
    style C1 fill:#FFE4B5
    style C2 fill:#FFE4B5
```

#### ì£¼ìš” êµ¬í˜„ ì‚¬í•­
- **Replication ì‹œìŠ¤í…œ**: Actor ë° Component ë ˆë²¨ì—ì„œì˜ ë°ì´í„° ë™ê¸°í™”
- **RPC(Remote Procedure Call)**: Server/Client/Multicast RPCë¥¼ í™œìš©í•œ ìƒíƒœ ì „íŒŒ
- **Authority ê¸°ë°˜ ë¡œì§ ë¶„ë¦¬**: ì„œë²„ì—ì„œë§Œ ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” ê²Œì„ ë¡œì§ ë³´í˜¸

```cpp
// GameStateì—ì„œ Counter POS ë³µì œ
void AMHGAGameState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    DOREPLIFETIME(AMHGAGameState, Counter);
}
```

#### ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™” ì „ëµ
- **ì¬ë£Œ ë° Props**: `bReplicates = true` + `SetReplicateMovement(true)`ë¡œ ë¬¼ë¦¬ ê¸°ë°˜ ë™ì‘ ë™ê¸°í™”
  ```cpp
  // IngredientBase ìƒì„±ì
  AIngredientBase::AIngredientBase()
  {
      bReplicates = true;
      AActor::SetReplicateMovement(true);
  }
  
  // BeginPlayì—ì„œ í´ë¼ì´ì–¸íŠ¸ ë¬¼ë¦¬ ë¹„í™œì„±í™”
  void AIngredientBase::BeginPlay()
  {
      if (HasAuthority() == false)
      {
          Mesh->SetSimulatePhysics(false);
          Mesh->SetEnableGravity(false);
      }
  }
  ```
- **UI ìƒí˜¸ì‘ìš©**: PlayerControllerë¥¼ í†µí•œ Server RPC â†’ Counter Actorì˜ Multicast RPC ì²´ì¸
- **ì†ë‹˜ AI**: ì„œë²„ì—ì„œë§Œ FSM ë¡œì§ ì‹¤í–‰, ê²°ê³¼ë§Œ ë³µì œ

---

### 2. AI ì†ë‹˜ ì‹œìŠ¤í…œ

**ìœ í•œ ìƒíƒœ ë¨¸ì‹ (FSM) ê¸°ë°˜ì˜ ì†ë‹˜ í–‰ë™ AI**

#### ì†ë‹˜ ì¢…ë¥˜ ë° ì„±ê²© ì‹œìŠ¤í…œ

**ì†ë‹˜ ì„±ê²© (ECustomerPersonality)**
```cpp
UENUM(BlueprintType)
enum class ECustomerPersonality : uint8
{
    Standard    UMETA(DisplayName = "í‘œì¤€"),
    Polite      UMETA(DisplayName = "ê³µì†í•¨"),
    Rude        UMETA(DisplayName = "ë¬´ë¡€í•¨"),
    Impatient   UMETA(DisplayName = "ê¸‰í•¨"),
    Special_VIP UMETA(DisplayName = "ë§¤ê·¸ë„ˆìŠ¤")  // íŠ¹ë³„ ì†ë‹˜
};
```

**íŠ¹ë³„ ì†ë‹˜ ì‹œìŠ¤í…œ**
- **ìƒì„± í™•ë¥ **: `SpecialCustomerChance = 0.1f` (10%)
- **íŠ¹ë³„ ì£¼ë¬¸**: `EBurgerMenu::WrongBurger` (í•­ìƒ ì˜ëª»ëœ ë²„ê±° ì£¼ë¬¸)
- **ì „ìš© ë©”ì‰¬ ë° ì• ë‹ˆë©”ì´ì…˜**: `specialVisual` ì‚¬ìš©
- **ë©”ì‰¬ ì¸ë±ìŠ¤**: -1 (ì¼ë°˜ ì†ë‹˜ê³¼ êµ¬ë¶„)

```cpp
// CustomerFSM::BeginPlayì—ì„œ ì†ë‹˜ íƒ€ì… ê²°ì •
if (FMath::FRand() < SpecialCustomerChance)
{
    // íŠ¹ë³„ ì†ë‹˜
    personality = ECustomerPersonality::Special_VIP;
    SelectedMeshIndex = -1;  // íŠ¹ë³„ ì†ë‹˜ ë©”ì‰¬
}
else
{
    // ì¼ë°˜ ì†ë‹˜
    int32 NumRegularPersonalities = static_cast<int32>(ECustomerPersonality::Special_VIP);
    personality = static_cast<ECustomerPersonality>(FMath::RandRange(0, NumRegularPersonalities - 1));
    SelectedMeshIndex = FMath::RandRange(0, me->regularVisuals.Num() - 1);
}
```

#### ì†ë‹˜ ìƒíƒœ ì „í™˜ ë‹¤ì´ì–´ê·¸ë¨

```mermaid
graph TD
    A["ğŸš¶ ì…ì¥<br/>(Spawn)"] --> B{"ëŒ€ê¸°ì—´<br/>ìë¦¬?"}
    B -->|Yes| C["â¡ï¸ ëŒ€ê¸°ì—´ ì´ë™<br/>(GoingToLine)"]
    B -->|No| D["ğŸ”„ ë°°íšŒ<br/>(Wandering)"]
    C --> E["â³ ì¤„ ì„œì„œ ëŒ€ê¸°<br/>(WaitingInLine)"]
    D --> E
    E --> F["ğŸ—£ï¸ ì£¼ë¬¸ ì¤‘<br/>(Ordering)"]
    F --> G["â³ ìŒì‹ ëŒ€ê¸°<br/>(WaitingForFood)"]
    G --> H{"ë°°íšŒ<br/>í•„ìš”?"}
    H -->|Yes| D
    H -->|No| I["â¡ï¸ í”½ì—…ì¡´ ì´ë™<br/>(GoingToPickup)"]
    D --> I
    I --> J["â³ í”½ì—… ëŒ€ê¸°<br/>(WaitingForPickup)"]
    J --> K["âœ“ ìŒì‹ ê²€ì¦<br/>& ìˆ˜ë ¹"]
    K --> L["ğŸšª í‡´ì¥<br/>(Exit)"]

    style A fill:#FFE4B5
    style F fill:#87CEEB
    style K fill:#98FB98
    style L fill:#DDA0DD
```

#### FSM êµ¬ì¡° (CustomerFSM)
ì´ 9ê°€ì§€ ìƒíƒœë¥¼ ê°€ì§„ ìœ í•œ ìƒíƒœ ë¨¸ì‹ ìœ¼ë¡œ ì†ë‹˜ì˜ í–‰ë™ì„ ì œì–´í•©ë‹ˆë‹¤.

```cpp
enum class EAIState : uint8
{
    None,              // ì´ˆê¸° ìƒíƒœ
    GoingToLine,       // ì¤„ ì„œëŸ¬ ì´ë™ ì¤‘
    WaitingInLine,     // ì¤„ ì„œì„œ ëŒ€ê¸° ì¤‘
    Wandering,         // ë°°íšŒ ì¤‘
    Ordering,          // ì£¼ë¬¸ ì¤‘
    WaitingForFood,    // ìŒì‹ ëŒ€ê¸° ì¤‘
    GoingToPickup,     // í”½ì—…ì¡´ ì´ë™ ì¤‘
    WaitingForPickup,  // í”½ì—…ì¡´ ëŒ€ê¸° ì¤‘
    Exit               // í‡´ì¥
};
```

#### ì£¼ìš” ê¸°ëŠ¥

**1. ëŒ€ê¸°ì—´ ê´€ë¦¬ ì‹œìŠ¤í…œ**
- ë¹ˆ ìë¦¬ê°€ ìˆìœ¼ë©´ ì¦‰ì‹œ ì¤„ì„œê¸°, ì—†ìœ¼ë©´ ë°°íšŒí•˜ë©° ëŒ€ê¸°
- ì†ë‹˜ì´ ì£¼ë¬¸ ì™„ë£Œ ì‹œ ìë™ìœ¼ë¡œ ëŒ€ê¸°ì—´ ì•ë‹¹ê¹€
- ëŒ€ê¸° ì¤‘ì¸ ì†ë‹˜ì„ ìˆœì°¨ì ìœ¼ë¡œ í˜¸ì¶œ

```cpp
void ACustomerManager::UpdateWaitingPosition()
{
    for (int32 i = 1; i < waitingCustomers.Num(); ++i)
    {
        if (waitingCustomers[i] != nullptr && waitingCustomers[i - 1] == nullptr)
        {
            // ì•ìë¦¬ë¡œ ì´ë™ ëª…ë ¹
            ACustomerAI* customerToMove = waitingCustomers[i];
            customerToMove->fsm->MoveToTarget(waitingPoints[i-1]);
            waitingCustomers[i-1] = waitingCustomers[i];
            waitingCustomers[i] = nullptr;
        }
    }
}
```

**2. ë°°íšŒ ì‹œìŠ¤í…œ**
- NavigationSystemì„ í™œìš©í•œ NavMesh ê¸°ë°˜ ëœë¤ ì´ë™
- 3~5ì´ˆ ê°„ê²©ìœ¼ë¡œ ìƒˆë¡œìš´ ëª©ì ì§€ ì„¤ì •
- íƒ€ì´ë¨¸ë¥¼ í™œìš©í•œ ë¹„ë™ê¸° ì²˜ë¦¬

**3. ì£¼ë¬¸ ì‹œìŠ¤í…œ**
- Enum ê¸°ë°˜ ë©”ë‰´ ì„ íƒ (BigMac, BTD, QPC, Shanghai, Shrimp)
- UMG ìœ„ì ¯ì„ í†µí•œ ë§í’ì„  UI í‘œì‹œ
- ì£¼ë¬¸ ì™„ë£Œ ì‹œ ìë™ìœ¼ë¡œ ìŒì‹ ëŒ€ê¸° ìƒíƒœë¡œ ì „í™˜

**4. ìŒì‹ ê²€ì¦ ì‹œìŠ¤í…œ**
- í”½ì—…ì¡´ì—ì„œ ìŒì‹ ì´ë¦„ê³¼ ì£¼ë¬¸í•œ ë©”ë‰´ ë¹„êµ
- ì¼ì¹˜ ì‹œ ë§Œì¡± í‘œì‹œ, ë¶ˆì¼ì¹˜ ì‹œ ë¶ˆë§Œ í‘œì‹œ
- í‰ì  ì‹œìŠ¤í…œ ì—°ë™ (ShowScoreFeedback í•¨ìˆ˜ë¡œ êµ¬í˜„)

```cpp
void UCustomerFSM::CheckAndTakeFood()
{
    if (MyPickupZone->HasFood())
    {
        AHamburger* TakenHamburger = Cast<AHamburger>(MyPickupZone->TakeFood());
        FString OrderedMenuName = // Enumì„ Stringìœ¼ë¡œ ë³€í™˜
        FString TakenBurgerName = TakenHamburger->GetBurgerName();

        if (OrderedMenuName == TakenBurgerName)
        {
            me->ShowScoreFeedback(EScoreChangeReason::CorrectFood);  // ë§Œì¡±
        }
        else
        {
            me->ShowScoreFeedback(EScoreChangeReason::WrongFood);  // ë¶ˆë§Œ
        }
    }
}
```

**5. ì†ë‹˜ ë§¤ë‹ˆì € (CustomerManager)**
- íƒ€ì´ë¨¸ ê¸°ë°˜ ìë™ ìŠ¤í° ì‹œìŠ¤í…œ
- ìµœëŒ€ ì¸ì› ì œí•œ ê´€ë¦¬ (MaxSpawnedCustomers)
- í”½ì—… ëŒ€ê¸°ì—´ ê´€ë¦¬ ë° í˜¸ì¶œ ì‹œìŠ¤í…œ

---

### 3. ì¡°ë¦¬ ì‹œìŠ¤í…œ

**ë¬¼ë¦¬ ê¸°ë°˜ ìƒí˜¸ì‘ìš©ê³¼ ìƒíƒœ ë¨¸ì‹ ì„ ê²°í•©í•œ ì¡°ë¦¬ ë©”ì»¤ë‹ˆì¦˜**

#### ì¬ë£Œ ì‹œìŠ¤í…œ (Ingredient System)

**ì¬ë£Œ í´ë˜ìŠ¤ ê³„ì¸µ êµ¬ì¡°**
```
IngredientBase (ê¸°ë³¸ ì¬ë£Œ í´ë˜ìŠ¤, IngType = None)
â”œâ”€â”€ BottomBread (IngType = BottomBread)
â”œâ”€â”€ MiddleBread (IngType ë¯¸ì„¤ì •)
â”œâ”€â”€ TopBread (IngType = TopBread)
â”œâ”€â”€ Patty (IngType = Patty, ì¡°ë¦¬ ìƒíƒœ í¬í•¨)
â”œâ”€â”€ Cheese (IngType = Cheese)
â”œâ”€â”€ Lettuce (IngType ë¯¸ì„¤ì •)
â”œâ”€â”€ Tomato (IngType ë¯¸ì„¤ì •)
â”œâ”€â”€ Onion (IngType = Onion)
â”œâ”€â”€ Pickle (IngType = Pickle)
â””â”€â”€ SauceBottle (IngType = None, ë°œì‚¬ ê¸°ëŠ¥)
```

**ì£¼ìš” êµ¬í˜„ ì¬ë£Œ**
- `BottomBread`, `TopBread`: í–„ë²„ê±° ìƒí•˜ ë¹µ
- `Patty`: 3ë‹¨ê³„ ì¡°ë¦¬ ìƒíƒœ (Raw â†’ Cooked â†’ Overcooked)
- `Cheese`, `Onion`, `Pickle`: í† í•‘ ì¬ë£Œ
- `SauceBottle`: Line Trace ê¸°ë°˜ ì†ŒìŠ¤ ë°œì‚¬

**ì¬ë£Œ Enum ì •ì˜**
```cpp
enum class EIngredient : uint8
{
    None, BottomBread, MiddleBread, TopBread,
    Patty, Lettuce, Tomato, Onion,
    Cheese, Pickle, Sauce, ShanghaiPortion, ShrimpPortion
};
```

#### íŒ¨í‹° ì¡°ë¦¬ ì‹œìŠ¤í…œ

**Patty í´ë˜ìŠ¤** ë° **CookingArea**ë¥¼ í†µí•œ 3ë‹¨ê³„ ì¡°ë¦¬ ìƒíƒœ êµ¬í˜„

```cpp
enum class EPattyCookState : uint8
{
    Raw,        // ë‚ ê²ƒ
    Cooked,     // ì ì ˆíˆ êµ¬ì›Œì§
    Overcooked  // íƒ€ë²„ë¦¼
};
```

**íŒ¨í‹° ì¡°ë¦¬ì˜ íŠ¹ì§•**
- **ì•ë’·ë©´ ê°œë³„ ê´€ë¦¬**: íŒ¨í‹°ì˜ ì•ë©´ê³¼ ë’·ë©´ì„ ê°ê° ë”°ë¡œ ìš”ë¦¬
- **ë’¤ì§‘ê¸° ë©”ì»¤ë‹ˆì¦˜**: Flip() í•¨ìˆ˜ë¡œ ì•ë’·ë©´ ìƒíƒœë¥¼ ì „í™˜
- **íƒ€ì´ë¨¸ ê¸°ë°˜ ì¡°ë¦¬**: cookTime(3ì´ˆ)ê³¼ overcookTime(5ì´ˆ) ê¸°ë³¸ê°’
- **ìƒíƒœë³„ í…ìŠ¤ì²˜ ë³€ê²½**: Raw â†’ Cooked â†’ Overcooked ìƒíƒœì— ë”°ë¼ í…ìŠ¤ì²˜ ë™ì  ë³€ê²½

**íŒ¨í‹° ì¡°ë¦¬ íƒ€ì„ë¼ì¸**

```mermaid
timeline
    title íŒ¨í‹° ì¡°ë¦¬ ê³¼ì • (í•œìª½ ë©´ ê¸°ì¤€)
    section ìƒíƒœ ë³€í™”
        Raw (ë‚ ê²ƒ) : ì‹œì‘ : ì›ë³¸ í…ìŠ¤ì²˜
        0ì´ˆ : ì¡°ë¦¬ ì˜ì—­ ì§„ì… : StartCook() í˜¸ì¶œ
        3ì´ˆ : Cooked ìƒíƒœ ì „í™˜ : ìƒ‰ìƒ ë³€ê²½ (cookTime)
        8ì´ˆ : Overcooked ìƒíƒœ ì „í™˜ : ê²€ì€ìƒ‰ í…ìŠ¤ì²˜ (overcookTime ì¶”ê°€)
    section ì¡°ë¦¬ ìƒíƒœ
        í˜„ì¬ë©´ ì¡°ë¦¬ ì¤‘ : 3~8ì´ˆ : bCurrentSideCooked = true
        í˜„ì¬ë©´ ì˜¤ë²„ì¿¡ : 8ì´ˆ+ : bCurrentSideOverCooked = true
```

**íŒ¨í‹° ì¡°ë¦¬ ìƒíƒœ ì—…ë°ì´íŠ¸ ë¡œì§**
```cpp
// Patty.h - ì•ë’·ë©´ ìƒíƒœ ì¶”ì 
UPROPERTY(ReplicatedUsing = OnRep_CookStateChanged)
bool bIsFrontCooked;      // ì•ë©´ êµ¬ì›Œì§
UPROPERTY(ReplicatedUsing = OnRep_CookStateChanged)
bool bIsBackCooked;       // ë’·ë©´ êµ¬ì›Œì§
UPROPERTY(ReplicatedUsing = OnRep_CookStateChanged)
bool bIsFrontOverCooked;  // ì•ë©´ ì˜¤ë²„ì¿¡
UPROPERTY(ReplicatedUsing = OnRep_CookStateChanged)
bool bIsBackOverCooked;   // ë’·ë©´ ì˜¤ë²„ì¿¡

// ì¢…í•© ìƒíƒœ ê³„ì‚°
UPROPERTY(Replicated)
EPattyCookState CookState;  // Raw / Cooked / Overcooked

// CookingAreaì™€ì˜ ìƒí˜¸ì‘ìš©
void ACookingArea::OnOverlapBegin(...)
{
    AIngredientBase* ingredient = Cast<AIngredientBase>(OtherActor);
    if (ingredient)
        ingredient->StartCook();  // íŒ¨í‹°ì˜ StartCook() í˜¸ì¶œ
}
```

#### ì†ŒìŠ¤ ë°œì‚¬ ì‹œìŠ¤í…œ

**SauceBottle í´ë˜ìŠ¤**ì˜ íŠ¹ìˆ˜ ê¸°ëŠ¥
- Arrow Componentë¡œ ë°œì‚¬ ë°©í–¥ ì‹œê°í™”
- ShootSauce() í•¨ìˆ˜ë¡œ ì†ŒìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ìŠ¤í°
- ì‹¤ì‹œê°„ ë¬¼ë¦¬ ê¸°ë°˜ ì†ŒìŠ¤ ìƒì„±

```cpp
class ASauceBottle : public AIngredientBase
{
public:
    // ì†ŒìŠ¤ ë°œì‚¬ í•¨ìˆ˜
    void ShootSauce();

    virtual void OnUse() override;  // ë§ˆìš°ìŠ¤ í´ë¦­ ì‹œ í˜¸ì¶œ

protected:
    UPROPERTY(VisibleAnywhere)
    class UArrowComponent* Arrow;  // ë°œì‚¬ ë°©í–¥ í‘œì‹œ

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TSubclassOf<class AIngredientBase> SauceClass;  // ìŠ¤í°ë  ì†ŒìŠ¤ í´ë˜ìŠ¤
};
```

---

### 4. í¬ì¥ ë° ë ˆì‹œí”¼ ê²€ì¦ ì‹œìŠ¤í…œ

**WrappingPaper í´ë˜ìŠ¤ë¥¼ í†µí•œ í–„ë²„ê±° ì™„ì„± ë° ê²€ì¦**

#### ì‘ë™ ì›ë¦¬

**1. ì¬ë£Œ ì¶”ì **
- Box Collisionì„ í†µí•œ Overlap ì´ë²¤íŠ¸ ê°ì§€
- ì¬ë£Œ ì¢…ë¥˜ë³„ ìˆ˜ëŸ‰ ì¹´ìš´íŠ¸
- TArray<FIngredientStack> êµ¬ì¡°ë¡œ ê´€ë¦¬

```cpp
struct FIngredientStack
{
    EIngredient IngredientId;
    int32 Quantity;
};
```

**2. í¬ì¥ ì¡°ê±´ ê²€ì¦**
```cpp
bool AWrappingPaper::HasBreadPair() const
{
    // TopBreadì™€ BottomBreadê°€ ê°ê° 1ê°œ ì´ìƒ í•„ìš”
    int32 Q_TBread = 0, Q_BBread = 0;
    for (const FIngredientStack& tmp : OnAreaIngredients)
    {
        if (tmp.IngredientId == EIngredient::TopBread) Q_TBread++;
        if (tmp.IngredientId == EIngredient::BottomBread) Q_BBread++;
    }
    return Q_TBread >= 1 && Q_BBread >= 1;
}

bool AWrappingPaper::HasExtraIngredient() const
{
    // ë¹µ ì™¸ì— ë‹¤ë¥¸ ì¬ë£Œê°€ 1ê°œ ì´ìƒ í•„ìš”
    int32 count = 0;
    for (const FIngredientStack& tmp : OnAreaIngredients)
    {
        if (!(tmp.IngredientId == EIngredient::BottomBread || 
              tmp.IngredientId == EIngredient::TopBread))
            count++;
    }
    return count > 0;
}
```

**3. ë ˆì‹œí”¼ ë§¤ì¹­ ì•Œê³ ë¦¬ì¦˜**

DataTableì„ í™œìš©í•œ ì •í™•í•œ ë ˆì‹œí”¼ ë¹„êµ

**ë ˆì‹œí”¼ ë§¤ì¹­ í”„ë¡œì„¸ìŠ¤**

```mermaid
graph TD
    A["ğŸ“¦ í¬ì¥ì§€ì—<br/>ì¬ë£Œ ë°°ì¹˜ ì™„ë£Œ"] --> B["ğŸ” Wrapper<br/>ì¬ë£Œ ì¶”ì¶œ"]
    B --> C["ğŸ“Š WrapMap<br/>TMap ìƒì„±<br/>Ingredient â†’ Qty"]

    C --> D["ğŸ“– DataTable<br/>ëª¨ë“  ë ˆì‹œí”¼ ë¡œë“œ"]
    D --> E["ğŸ”„ ê° ë ˆì‹œí”¼<br/>ë°˜ë³µ ê²€ì¦"]

    E --> F{"ì¬ë£Œ ìˆ˜<br/>ì¼ì¹˜?"}
    F -->|No| E
    F -->|Yes| G{"ëª¨ë“  ì¬ë£Œ<br/>& ìˆ˜ëŸ‰<br/>ì¼ì¹˜?"}

    G -->|No| E
    G -->|Yes| H["âœ… ë§¤ì¹­ ì„±ê³µ<br/>ë²„ê±°ëª… ë°˜í™˜"]

    E --> I{"ë” ì´ìƒ<br/>ë ˆì‹œí”¼?"}
    I -->|Yes| J["âŒ ë§¤ì¹­ ì‹¤íŒ¨<br/>WrongBurger ë°˜í™˜"]

    A --> K["ì˜ˆì‹œ: ë¹…ë§¥<br/>Bottom Bread x1<br/>Patty x2<br/>Cheese x2<br/>Lettuce x1<br/>Top Bread x1"]

    H --> L["ğŸ” í–„ë²„ê±° ìƒì„±<br/>& ì˜ìˆ˜ì¦ ì¶œë ¥"]
    J --> M["ğŸ“ ì£¼ë¬¸ ê¸°ë¡<br/>ì˜ëª»ëœ ìŒì‹"]

    style A fill:#FFE4B5
    style B fill:#87CEEB
    style C fill:#90EE90
    style D fill:#87CEEB
    style E fill:#DDA0DD
    style F fill:#FFB6C1
    style G fill:#FFB6C1
    style H fill:#98FB98
    style I fill:#FFB6C1
    style J fill:#FFB6C1
    style K fill:#F0E68C
    style L fill:#90EE90
    style M fill:#FFB6C1
```

**ë ˆì‹œí”¼ ë§¤ì¹­ ì½”ë“œ**

```cpp
EBurgerMenu AWrappingPaper::FindMatchingRecipe(
    UDataTable* DT,
    const TArray<FIngredientStack>& WrapperIngr)
{
    TMap<EIngredient, int32> WrapMap = MakeMapFromArray(WrapperIngr);
    TArray<FBurgerRecipe*> AllRows;
    DT->GetAllRows<FBurgerRecipe>(TEXT("FBurgerRecipe"), AllRows);

    for (FBurgerRecipe* Row : AllRows)
    {
        TMap<EIngredient, int32> RecipeMap = MakeMapFromArray(Row->Ingredients);

        // ì¬ë£Œ ìˆ˜ê°€ ë‹¤ë¥´ë©´ ìŠ¤í‚µ
        if (RecipeMap.Num() != WrapMap.Num()) continue;

        // ëª¨ë“  ì¬ë£Œì™€ ìˆ˜ëŸ‰ì´ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦
        bool isMatched = true;
        for (const auto& Pair : RecipeMap)
        {
            const int32* WrapQty = WrapMap.Find(Pair.Key);
            if (WrapQty == nullptr || *WrapQty != Pair.Value)
            {
                isMatched = false;
                break;
            }
        }

        if (isMatched) return Row->BurgerName;
    }

    return EBurgerMenu::WrongBurger;
}
```

**4. í–„ë²„ê±° ìƒì„± ë° ì •ë¦¬**
```cpp
void AWrappingPaper::CompleteWrapping()
{
    // ë ˆì‹œí”¼ ë§¤ì¹­
    EBurgerMenu CreatedBurgerName = FindMatchingRecipe(
        BurgerDataTable, 
        OnAreaIngredients
    );
    
    // í–„ë²„ê±° ìŠ¤í°
    AHamburger* SpawnedBurger = GetWorld()->SpawnActor<AHamburger>(
        BurgerClass, 
        this->GetActorTransform()
    );
    SpawnedBurger->SetName(BurgerMenuName);
    
    // ì¬ë£Œ ë° í¬ì¥ì§€ ì •ë¦¬
    DestroyIngredients();
}
```

#### ì§€ì› ë©”ë‰´
```cpp
enum class EBurgerMenu : uint8
{
    None,
    WrongBurger,  // ì˜ëª»ëœ ì¡°í•©
    BigMac,       // ë¹…ë§¥
    BTD,          // ë² ì´ì»¨ í† ë§ˆí†  ë””ëŸ­ìŠ¤
    QPC,          // ì¿¼í„° íŒŒìš´ë“œ ì¹˜ì¦ˆ
    Shanghai,     // ìƒí•˜ì´ ë²„ê±°
    Shrimp        // ìƒˆìš° ë²„ê±°
};
```

---

### 5. POS(Point of Sale) ì‹œìŠ¤í…œ

**3D Widget Interactionì„ í™œìš©í•œ ì‹¤ì‹œê°„ ì£¼ë¬¸ ê´€ë¦¬**

#### ì‹œìŠ¤í…œ êµ¬ì¡°

**CounterPOS (Actor)**
- Static Meshë¡œ ëœ ì¹´ìš´í„° ëª¨ë¸
- Widget Componentë¥¼ í†µí•œ 3D UI í‘œì‹œ
- ë„¤íŠ¸ì›Œí¬ ë³µì œë¥¼ í†µí•œ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ë™ê¸°í™”

```cpp
ACounterPOS::ACounterPOS()
{
    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));
    WidgetComponent = CreateDefaultSubobject<UWidgetComponent>(TEXT("Widget"));
    
    bReplicates = true;
    bAlwaysRelevant = true;
    WidgetComponent->SetIsReplicated(true);
}
```

#### ì£¼ë¬¸ ê´€ë¦¬ êµ¬ì¡°

**FOrderArray êµ¬ì¡°ì²´**
```cpp
struct FOrderArray
{
    ACustomerAI* Customer;           // ì£¼ë¬¸í•œ ì†ë‹˜
    TArray<EBurgerMenu> Menus;       // ì£¼ë¬¸ ë©”ë‰´ ë¦¬ìŠ¤íŠ¸
};

// CounterPOSì—ì„œ ê´€ë¦¬
TMap<int32, FOrderArray> OrderMap;  // ì£¼ë¬¸ë²ˆí˜¸ â†’ ì£¼ë¬¸ì •ë³´
```

#### UI êµ¬ì„±

**1. CounterUI (ë©”ì¸ UI)**
- **CustomerCanvas**: ì£¼ë¬¸ ì™„ë£Œ ëª©ë¡ í‘œì‹œ
  - UniformGridPanelë¡œ 5ì—´ ê·¸ë¦¬ë“œ êµ¬ì„±
  - ê° ì£¼ë¬¸ì€ CustomerButtonUIë¡œ í‘œí˜„
  
- **OrderCanvas**: ë©”ë‰´ ì„ íƒ ë° ì£¼ë¬¸ ì ‘ìˆ˜
  - MenuGrid: ë™ì ìœ¼ë¡œ ìƒì„±ë˜ëŠ” ë©”ë‰´ ë²„íŠ¼
  - SelectedListBox: í˜„ì¬ ì„ íƒëœ ë©”ë‰´ ë¦¬ìŠ¤íŠ¸
  - ì£¼ë¬¸/ì‚­ì œ ë²„íŠ¼

**2. MenuButtonUI (ë©”ë‰´ ë²„íŠ¼)**
```cpp
void UMenuButtonUI::Init(const EBurgerMenu InName, UCounterUI* InOwner)
{
    MenuName = InName;
    CounterUI = InOwner;
    // Enumì„ DisplayNameìœ¼ë¡œ ë³€í™˜í•˜ì—¬ í‘œì‹œ
    TEXT_MenuName->SetText(
        StaticEnum<EBurgerMenu>()->GetDisplayNameTextByValue(
            static_cast<int64>(MenuName)
        )
    );
}
```

**3. CustomerButtonUI (ì£¼ë¬¸ ë²ˆí˜¸ ë²„íŠ¼)**
```cpp
class UCustomerButtonUI : public UUserWidget
{
    int32 Num;                      // ì£¼ë¬¸ ë²ˆí˜¸
    TArray<EBurgerMenu> Menus;      // ì£¼ë¬¸ ë©”ë‰´
    ACustomerAI* Customer;          // ì†ë‹˜ ì°¸ì¡° (ë¯¸ì‚¬ìš©)
    
    void Init(TArray<EBurgerMenu> InMenu, int32 InNum, UCounterUI* InOwner);
};
```
- ì£¼ë¬¸ ë²ˆí˜¸ í‘œì‹œ
- í´ë¦­ ì‹œ í•´ë‹¹ ì£¼ë¬¸ì˜ ë©”ë‰´ ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
- ì¤€ë¹„ ì™„ë£Œ ì²˜ë¦¬ ê¸°ëŠ¥

#### ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™” íë¦„

**ì£¼ë¬¸ ì ‘ìˆ˜ ë° ì™„ë£Œ í”„ë¡œì„¸ìŠ¤**

```mermaid
graph TD
    subgraph "Client Action"
        A["ğŸ‘† í”Œë ˆì´ì–´ê°€<br/>ë©”ë‰´ ë²„íŠ¼ í´ë¦­"]
    end

    subgraph "Network RPC Chain"
        B["ğŸ“¤ ServerRPC<br/>AddMenuToList<br/>Client â†’ Server"]
        C["âœ“ ì„œë²„ ê²€ì¦<br/>& ì²˜ë¦¬"]
        D["ğŸ“¢ MulticastRPC<br/>AddMenuToList<br/>Server â†’ All"]
    end

    subgraph "Client Update"
        E["ğŸ¨ Client 1<br/>UI ì—…ë°ì´íŠ¸"]
        F["ğŸ¨ Client 2<br/>UI ì—…ë°ì´íŠ¸"]
    end

    subgraph "Order Completion"
        G["ğŸ“ ì£¼ë¬¸ ì €ì¥<br/>OrderMap"]
        H["ğŸ§¾ ì˜ìˆ˜ì¦ ìƒì„±<br/>ReceiptActor Spawn"]
        I["ğŸ¤– AI ì†ë‹˜<br/>ìƒíƒœ ì „í™˜"]
    end

    A --> B
    B --> C
    C --> D
    D --> E
    D --> F
    C --> G
    G --> H
    G --> I

    style A fill:#FFE4B5
    style B fill:#87CEEB
    style C fill:#90EE90
    style D fill:#87CEEB
    style E fill:#FFE4B5
    style F fill:#FFE4B5
    style G fill:#F0E68C
    style H fill:#F0E68C
    style I fill:#DDA0DD
```

**ì£¼ë¬¸ ì™„ë£Œ ìƒì„¸ í”„ë¡œì„¸ìŠ¤**
```cpp
void UCounterUI::OrderMenuBtnRPC()
{
    // ì£¼ë¬¸ ì €ì¥
    PosActor->OrderMap.FindOrAdd(PosActor->OrderNum) = 
        {PosActor->GetCustomer(), OrderList};
    
    // ì£¼ë¬¸ ë²ˆí˜¸ ë²„íŠ¼ ìƒì„±
    UCustomerButtonUI* NewCustomerBtn = CreateWidget<UCustomerButtonUI>(...);
    NewCustomerBtn->Init(OrderList, PosActor->OrderNum, this);
    CustomerGrid->AddChildToUniformGrid(NewCustomerBtn, Row, Col);
    
    // ì˜ìˆ˜ì¦ ì¶œë ¥ (ì„œë²„ì—ì„œë§Œ)
    if (PosActor->HasAuthority())
    {
        AReceiptActor* NewReceipt = GetWorld()->SpawnActor<AReceiptActor>(...);
        NewReceipt->MulticastRPC_Init(OrderNum, MenuStrings);
    }
    
    // AI ì†ë‹˜ ì£¼ë¬¸ ì™„ë£Œ ì²˜ë¦¬
    if (PosActor->GetCustomer() != nullptr)
        PosActor->GetCustomer()->fsm->FinishOrder();
}
```

#### ì˜ìˆ˜ì¦ ì‹œìŠ¤í…œ

**ReceiptActor í´ë˜ìŠ¤**
- Canvas Render Targetì„ í™œìš©í•œ ë™ì  í…ìŠ¤íŠ¸ ë Œë”ë§
- ì£¼ë¬¸ ë²ˆí˜¸ì™€ ë©”ë‰´ ë¦¬ìŠ¤íŠ¸ë¥¼ í…ìŠ¤ì²˜ë¡œ ë³€í™˜
- ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì ìš©ìœ¼ë¡œ í˜„ì‹¤ê° ìˆëŠ” ì¶œë ¥ íš¨ê³¼

```cpp
void AReceiptActor::OnUpdateCanvas(UCanvas* Canvas, int32 Width, int32 Height)
{
    // ë°°ê²½ í°ìƒ‰
    FCanvasTileItem TileItem(FVector2D(0, 0), 
                             FVector2D(Width, Height), 
                             FLinearColor::White);
    Canvas->DrawItem(TileItem);
    
    // ì£¼ë¬¸ ë²ˆí˜¸ í¬ê²Œ í‘œì‹œ
    FString OrderText = FString::Printf(TEXT("#%d"), OrderNum);
    // ... í…ìŠ¤íŠ¸ ë Œë”ë§
    
    // ë©”ë‰´ ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
    for (const FString& M : MenuList)
    {
        FCanvasTextItem MenuItem(...);
        Canvas->DrawItem(MenuItem);
    }
}
```

---

### 5.1 ë¡œë”© í™”ë©´ ì‹œìŠ¤í…œ

#### LoadingWidget í´ë˜ìŠ¤
- **ëª©ì **: ë ˆë²¨ ì „í™˜ ì‹œ í‘œì‹œë˜ëŠ” ë¡œë”© UI
- **êµ¬í˜„ ìœ„ì¹˜**: 
  - `Source/MHGA/Public/LoadingWidget.h`
  - `Source/MHGA/Private/LoadingWidget.cpp`
- **Blueprint**: `/Game/UI/WBP_LoadingUI`

#### LoadingBurger í´ë˜ìŠ¤  
- **ëª©ì **: ë¡œë”© í™”ë©´ì—ì„œ íšŒì „í•˜ëŠ” 3D ë²„ê±° í‘œì‹œ
- **ì£¼ìš” ì»´í¬ë„ŒíŠ¸**:
  - `SceneCaptureComponent2D`: ë²„ê±°ë¥¼ ë Œë” íƒ€ê²Ÿì— ìº¡ì²˜
  - `StaticMeshComponent`: íšŒì „í•˜ëŠ” ë²„ê±° ë©”ì‰¬
  - `RotationSpeed`: ì´ˆë‹¹ 90ë„ íšŒì „
- **êµ¬í˜„ ìœ„ì¹˜**: 
  - `Source/MHGA/Public/LoadingBurger.h`
  - `Source/MHGA/Private/LoadingBurger.cpp`

**ë¡œë”© í™”ë©´ ê´€ë¦¬ (MHGAGameInstance)**
```cpp
// MHGAGameInstance.h
private:
    UPROPERTY(EditDefaultsOnly, Category = "UI")
    TSubclassOf<class ULoadingWidget> LoadingWidgetClass;
    
    UPROPERTY()
    class ULoadingWidget* LoadingWidget;

public:
    void ShowLoadingScreen();
    void HideLoadingScreen();
```

**ë¡œë”© í™”ë©´ í‘œì‹œ/ìˆ¨ê¹€ êµ¬í˜„**
```cpp
void UMHGAGameInstance::ShowLoadingScreen()
{
    UWorld* World = GetWorld();
    if (!World) return;

    APlayerController* PC = World->GetFirstPlayerController();
    if (!PC) return;

    // Loading Widget ìƒì„±
    if (!LoadingWidget && LoadingWidgetClass)
    {
        LoadingWidget = CreateWidget<ULoadingWidget>(PC, LoadingWidgetClass);
    }

    // Widget í‘œì‹œ (ìµœìƒìœ„ Z-Order)
    if (LoadingWidget)
    {
        LoadingWidget->AddToViewport(9999);
    }
}

void UMHGAGameInstance::HideLoadingScreen()
{
    // Loading Widget ì œê±°
    if (LoadingWidget && LoadingWidget->IsInViewport())
    {
        LoadingWidget->RemoveFromParent();
    }

    // ì…ë ¥ ëª¨ë“œ ë³µêµ¬
    if (UWorld* World = GetWorld())
    {
        if (APlayerController* PC = World->GetFirstPlayerController())
        {
            PC->SetInputMode(FInputModeGameOnly());
            PC->bShowMouseCursor = false;
        }
    }
}
```

**PlayerController RPC**
```cpp
// í´ë¼ì´ì–¸íŠ¸ì— ë¡œë”© í‘œì‹œ ìš”ì²­
UFUNCTION(Client, Reliable)
void ClientShowLoading();

// í´ë¼ì´ì–¸íŠ¸ì— ë¡œë”© ìˆ¨ê¹€ ìš”ì²­  
UFUNCTION(Client, Reliable)
void ClientHideLoading();
```

#### ì‚¬ìš© ì‹œì  ë° íë¦„

1. **ë¡œë¹„ â†’ ë©”ì¸ ë ˆë²¨ ì „í™˜**
```cpp
void ULobbyUI::OnClickReady()
{
    if (LobbyBoard->HasAuthority())
    {
        // ëª¨ë“  í”Œë ˆì´ì–´ì—ê²Œ ë¡œë”©ì°½ í‘œì‹œ ìš”ì²­
        for (FConstPlayerControllerIterator It = GetWorld()->GetPlayerControllerIterator(); It; ++It)
        {
            if (AMHGAPlayerController* PC = Cast<AMHGAPlayerController>(It->Get()))
            {
                PC->ClientShowLoading();
            }
        }

        // ì•½ê°„ì˜ ì§€ì—° í›„ ì„œë²„ íŠ¸ë˜ë¸”
        FTimerHandle TimerHandle;
        GetWorld()->GetTimerManager().SetTimer(TimerHandle, [this]()
        {
            GetWorld()->ServerTravel(TEXT("/Game/Maps/Main"), true);
        }, 0.1f, false);
    }
}
```

2. **ë©”ì¸ ë ˆë²¨ ë„ì°© í›„ ë¡œë”© ìˆ¨ê¹€**
```cpp
void AMHGAGameMode::PostLogin(APlayerController* NewPlayer)
{
    Super::PostLogin(NewPlayer);

    if (AMHGAPlayerController* PC = Cast<AMHGAPlayerController>(NewPlayer))
    {
        // ì•½ê°„ì˜ ì§€ì—° í›„ ë¡œë”©ì°½ ìˆ¨ê¹€
        FTimerHandle TimerHandle;
        GetWorld()->GetTimerManager().SetTimer(TimerHandle, [PC]()
        {
            if (PC)
            {
                PC->ClientHideLoading();
            }
        }, 3.0f, false); // 3ì´ˆ í›„ ìˆ¨ê¹€
    }
}
```

3. **ê²Œì„ ì¢…ë£Œ â†’ ë¡œë¹„ ë³µê·€**
```cpp
void AMHGAGameMode::HandleGameOver(FString reason)
{
    // ... ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬ ...
    
    if (HasAuthority())
    {
        FTimerHandle handle;
        GetWorldTimerManager().SetTimer(handle, [this]()
        {
            GetWorld()->ServerTravel(TEXT("/Game/Maps/Lobby"), true);
        }, 10, false);
    }
}
```

---

### 5.2 ê²Œì„ ì˜¤ë²„ ì‹œìŠ¤í…œ

#### GameOverWidget í´ë˜ìŠ¤
- **ëª©ì **: ê²Œì„ ì¢…ë£Œ ì‹œ ì ìˆ˜ í‘œì‹œ ë° ê²°ê³¼ í™”ë©´
- **êµ¬í˜„ ìœ„ì¹˜**: 
  - `Source/MHGA/Public/GameOverWidget.h`
  - `Source/MHGA/Private/GameOverWidget.cpp`
- **ì‹¤ì œ êµ¬í˜„**: `PlayerWidget` í´ë˜ìŠ¤ ë‚´ì— í†µí•©ë˜ì–´ ìˆìŒ
  - `finalScore` Canvas Panel
  - `orderScoreBox`, `cookScoreBox`, `foodScoreBox` TextBlock
  - `FinalScoreAnim` ì• ë‹ˆë©”ì´ì…˜

#### MHGAGameState - ê²Œì„ ìƒíƒœ ê´€ë¦¬
- **í‰ì  ì‹œìŠ¤í…œ**: 
  - `orderSpeedScore`: ì£¼ë¬¸ ì†ë„ í‰ì 
  - `cookSpeedScore`: ì¡°ë¦¬ ì†ë„ í‰ì   
  - `foodScore`: ìŒì‹ ì •í™•ë„ í‰ì 
  - `finalScore`: ì´ í‰ì 
- **ê²Œì„ ìƒíƒœ í”Œë˜ê·¸**:
  - `bIsGamePlaying`: ê²Œì„ ì§„í–‰ ì¤‘ ì—¬ë¶€
  - `bIsGameOver`: ê²Œì„ ì¢…ë£Œ ì—¬ë¶€

**ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬ íë¦„**
```cpp
// 1. ì„œë²„ì—ì„œ ê²Œì„ ì˜¤ë²„ ê°ì§€ ë° ì²˜ë¦¬
void AMHGAGameMode::HandleGameOver(FString reason)
{
    AMHGAGameState* gs = GetGameState<AMHGAGameState>();
    if (gs && !gs->bIsGameOver)
    {
        gs->bIsGameOver = true;  // í”Œë˜ê·¸ ì„¤ì • (RepNotify ë°œë™)
        
        // ëª¨ë“  ì†ë‹˜ í‡´ì¥
        ACustomerManager* CustomerManager = Cast<ACustomerManager>(
            UGameplayStatics::GetActorOfClass(GetWorld(), ACustomerManager::StaticClass())
        );
        if (CustomerManager)
        {
            CustomerManager->KickAllCustomers();
        }
        
        // í´ë¼ì´ì–¸íŠ¸ì—ì„œ OnRep_GameOver í˜¸ì¶œë¨
        gs->OnRep_GameOver();
        
        // 10ì´ˆ í›„ ë¡œë¹„ë¡œ ì´ë™
        if (HasAuthority())
        {
            FTimerHandle handle;
            GetWorldTimerManager().SetTimer(handle, [this]()
            {
                GetWorld()->ServerTravel(TEXT("/Game/Maps/Lobby"), true);
            }, 10, false);
        }
    }
}

// 2. í´ë¼ì´ì–¸íŠ¸ ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬
void AMHGAGameState::OnRep_GameOver()
{
    if (bIsGameOver)
    {
        // ìµœì¢… ì ìˆ˜ UI í‘œì‹œ
        playerWidget->finalScore->SetVisibility(ESlateVisibility::Visible);
        playerWidget->PlayFinalScoreAnim();
        
        // í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬ì— ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬ ìš”ì²­
        AMHGAPlayerController* pc = Cast<AMHGAPlayerController>(
            UGameplayStatics::GetPlayerController(GetWorld(), 0)
        );
        if (pc)
        {
            // í”Œë ˆì´ì–´ ì…ë ¥ ì²˜ë¦¬ëŠ” GameModeì—ì„œ ì²˜ë¦¬
        }
    }
}
```

#### í‰ì  ì‹œìŠ¤í…œ

**í‰ì  ë³€ê²½ ì´ìœ  enum**
```cpp
UENUM(BlueprintType)
enum class EScoreChangeReason : uint8
{
    SlowOrder   UMETA(DisplayName="ì£¼ë¬¸ ì§€ì—°"),
    SlowCook    UMETA(DisplayName="ì¡°ë¦¬ ì§€ì—°"),
    WrongFood   UMETA(DisplayName="ì˜ëª»ëœ ìŒì‹"),
    CorrectFood UMETA(DisplayName="ì˜¬ë°”ë¥¸ ìŒì‹")
};
```

**ì ìˆ˜ ì‹œìŠ¤í…œ ë‹¤ì´ì–´ê·¸ë¨**

```mermaid
graph TB
    subgraph "Game Events"
        E1["â³ ì£¼ë¬¸ ì§€ì—°<br/>ì†ë‹˜ì´ ì˜¤ë˜ ëŒ€ê¸°"]
        E2["ğŸ³ ì¡°ë¦¬ ì§€ì—°<br/>ìŒì‹ì´ ëŠ¦ê²Œ ë‚˜ì˜´"]
        E3["âŒ ì˜ëª»ëœ ìŒì‹<br/>ë ˆì‹œí”¼ ë¶ˆì¼ì¹˜"]
        E4["âœ… ì˜¬ë°”ë¥¸ ìŒì‹<br/>ì •í™•í•œ ë ˆì‹œí”¼"]
    end

    subgraph "Score Change"
        S1["ğŸ“Š orderSpeedScore<br/>-5ì "]
        S2["ğŸ“Š cookSpeedScore<br/>-10ì "]
        S3["ğŸ“Š foodScore<br/>-15ì "]
        S4["ğŸ“Š foodScore<br/>+10ì "]
    end

    subgraph "Final Score Calculation"
        TOTAL["ğŸ¯ finalScore<br/>= orderSpeed + cookSpeed + foodScore"]
    end

    subgraph "Rating"
        R1["â­â­â­â­ ë„Œ ì •ì§ì› í•´ë¼<br/>250ì  ì´ìƒ"]
        R2["â­â­â­ ì˜í•˜ì‹œë„¤ìš”<br/>150-249ì "]
        R3["â­â­ í‰ê· ì…ë‹ˆë‹¤<br/>100-149ì "]
        R4["â­ ë¶„ë°œí•˜ì„¸ìš”<br/>99ì  ì´í•˜"]
    end

    E1 --> S1
    E2 --> S2
    E3 --> S3
    E4 --> S4

    S1 --> TOTAL
    S2 --> TOTAL
    S3 --> TOTAL
    S4 --> TOTAL

    TOTAL --> R1
    TOTAL --> R2
    TOTAL --> R3
    TOTAL --> R4

    style E1 fill:#FFB6C1
    style E2 fill:#FFB6C1
    style E3 fill:#FFB6C1
    style E4 fill:#98FB98
    style S1 fill:#FFB6C1
    style S2 fill:#FFB6C1
    style S3 fill:#FFB6C1
    style S4 fill:#98FB98
    style TOTAL fill:#F0E68C
    style R1 fill:#FFD700
    style R2 fill:#C0C0C0
    style R3 fill:#CD7F32
    style R4 fill:#A9A9A9
```

**GameModeì˜ í‰ì  ì„¤ì • ë³€ìˆ˜**
```cpp
// MHGAGameMode.h
UPROPERTY(EditAnywhere, Category = "Game Config")
int32 penaltySlowOrder = -5;      // ì£¼ë¬¸ ì§€ì—° íŒ¨ë„í‹°
UPROPERTY(EditAnywhere, Category = "Game Config")
int32 penaltySlowCook = -10;      // ì¡°ë¦¬ ì§€ì—° íŒ¨ë„í‹°
UPROPERTY(EditAnywhere, Category = "Game Config")
int32 penaltyWrongFood = -15;     // ì˜ëª»ëœ ìŒì‹ íŒ¨ë„í‹°
UPROPERTY(EditAnywhere, Category = "Game Config")
int32 bonusCorrectFood = 10;      // ì˜¬ë°”ë¥¸ ìŒì‹ ë³´ë„ˆìŠ¤
```

**í‰ì  ë³€ê²½ ì²˜ë¦¬**
```cpp
void AMHGAGameMode::ReportScoreChanged(EScoreChangeReason reason, int32 changeScore)
{
    if (!HasAuthority()) return;
    AMHGAGameState* gs = GetGameState<AMHGAGameState>();
    if (!gs || gs->bIsGameOver) return;

    int32* targetScore = nullptr;

    switch (reason)
    {
    case EScoreChangeReason::SlowOrder:
        targetScore = &gs->orderSpeedScore;
        changeScore = penaltySlowOrder;
        break;
    case EScoreChangeReason::SlowCook:
        targetScore = &gs->cookSpeedScore;
        changeScore = penaltySlowCook;
        break;
    case EScoreChangeReason::WrongFood:
        targetScore = &gs->foodScore;
        changeScore = penaltyWrongFood;
        break;
    case EScoreChangeReason::CorrectFood:
        targetScore = &gs->foodScore;
        changeScore = bonusCorrectFood;
        break;
    }

    if (targetScore && changeScore != 0)
    {
        *targetScore += changeScore;
        gs->finalScore = gs->orderSpeedScore + gs->cookSpeedScore + gs->foodScore;
    }
}
```

**ìµœì¢… í‰ê°€ ê¸°ì¤€**
```cpp
FText AMHGAGameState::GetFinalRank()
{
    if (finalScore >= 250)
        return FText::FromString(TEXT("ë„Œ ì •ì§ì› í•´ë¼"));
    else if (finalScore >= 150)
        return FText::FromString(TEXT("ì˜í•˜ì‹œë„¤ìš”"));
    else if (finalScore >= 100)
        return FText::FromString(TEXT("í‰ê· ì…ë‹ˆë‹¤"));
    else
        return FText::FromString(TEXT("ë¶„ë°œí•˜ì„¸ìš”"));
}
```

---

### 6. ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ

**InteractComponentë¥¼ í†µí•œ í†µí•© ìƒí˜¸ì‘ìš© ê´€ë¦¬**

#### ì‹œìŠ¤í…œ ê°œìš”

í”Œë ˆì´ì–´ê°€ ì›”ë“œì˜ ë‹¤ì–‘í•œ ì˜¤ë¸Œì íŠ¸ì™€ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆëŠ” ì»´í¬ë„ŒíŠ¸ ê¸°ë°˜ ì‹œìŠ¤í…œ

**ì§€ì› ìƒí˜¸ì‘ìš©**
- ì¬ë£Œ/ë„êµ¬ ì§‘ê¸° (Grab)
- ì¬ë£Œ ì»¨í…Œì´ë„ˆì—ì„œ êº¼ë‚´ê¸°
- ë„êµ¬ ì‚¬ìš© (Use)
- ì˜¤ë¸Œì íŠ¸ ë‚´ë ¤ë†“ê¸° (Put)

#### ìƒí˜¸ì‘ìš© í”Œë¡œìš°

```mermaid
graph TD
    A["âŒ¨ï¸ Eí‚¤ ì…ë ¥<br/>GrabProps"] --> B["ğŸ¯ Sweep<br/>Collision ê°ì§€"]
    B --> C{ì•¡í„°<br/>íƒ€ì… í™•ì¸}

    C -->|WrappingPaper| D["ğŸ“¦ TryWrap<br/>í¬ì¥ì§€ ìƒí˜¸ì‘ìš©"]
    C -->|IGrabableProps| E["âœ‹ MulticastRPC<br/>GrabProps ì‹¤í–‰"]
    C -->|IngContainer| F["ğŸ”„ ìŠ¤í°<br/>ìƒˆ ì¬ë£Œ ìƒì„±"]

    E --> G["ğŸ’« ë¬¼ë¦¬ ë¹„í™œì„±í™”<br/>Grab ìƒíƒœ"]
    G --> H["ğŸ¥ ì¹´ë©”ë¼ì—<br/>ë¶€ì°©"]

    D --> I["âœ“ ë ˆì‹œí”¼ ë§¤ì¹­"]
    I --> J["ğŸ” í–„ë²„ê±° ìƒì„±<br/>& ì˜ìˆ˜ì¦"]

    F --> H

    H --> K["ğŸ–±ï¸ ë§ˆìš°ìŠ¤<br/>ì‚¬ìš©/ì¢Œí´ë¦­"]
    K --> L{ë„êµ¬<br/>íƒ€ì…?}

    L -->|Flipper| M["âš¡ Flip ë™ì‘<br/>íŒ¨í‹° ë’¤ì§‘ê¸°"]
    L -->|SauceBottle| N["ğŸ’¦ Shoot<br/>ì†ŒìŠ¤ ë°œì‚¬"]
    L -->|ê¸°íƒ€| O["ğŸ”§ ì¼ë°˜ ì‚¬ìš©"]

    M --> P["Eí‚¤ ë‹¤ì‹œ<br/>PutProps"]
    N --> P
    O --> P

    P --> Q["ğŸª‘ ë¬¼ë¦¬ í™œì„±í™”<br/>ì›”ë“œì— ë°°ì¹˜"]

    style A fill:#FFE4B5
    style B fill:#87CEEB
    style C fill:#DDA0DD
    style D fill:#F0E68C
    style E fill:#90EE90
    style F fill:#90EE90
    style G fill:#FFB6C1
    style H fill:#FFB6C1
    style I fill:#F0E68C
    style J fill:#98FB98
    style K fill:#FFE4B5
    style L fill:#DDA0DD
    style M fill:#FFA07A
    style N fill:#FFA07A
    style O fill:#FFA07A
    style P fill:#FFB6C1
    style Q fill:#90EE90
```

#### IGrabableProps ì¸í„°í˜ì´ìŠ¤

```cpp
class IGrabableProps
{
    virtual void OnGrabbed(AMHGACharacter* Player) = 0;  // ì§‘í ë•Œ
    virtual void OnPut() = 0;                             // ë‚´ë ¤ë†“ì„ ë•Œ
    virtual void OnUse() = 0;                             // ì‚¬ìš©í•  ë•Œ
    virtual void SetLocation(FVector Loc) = 0;            // ìœ„ì¹˜ ì„¤ì •
};
```

```cpp
class AIngredientBase : public AActor, public IGrabableProps
{
    UPROPERTY(EditAnywhere)
    UStaticMeshComponent* Mesh;
    
    UPROPERTY(EditAnywhere)
    EIngredient IngType = EIngredient::None;
    
    UPROPERTY(EditAnywhere)
    AMHGACharacter* GrabCharacter;  // í˜„ì¬ ì§‘ê³  ìˆëŠ” ìºë¦­í„°
};
```

**ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ í´ë˜ìŠ¤**
- `AIngredientBase` ë° ëª¨ë“  í•˜ìœ„ ì¬ë£Œ í´ë˜ìŠ¤
- `AHamburger` (ì™„ì„±ëœ í–„ë²„ê±°)
- `AFlipper` (íŒ¨í‹° ë’¤ì§‘ê°œ, ìì²´ GrabCharacter í•„ë“œ ë³´ìœ )
- `AReceiptActor` (ì˜ìˆ˜ì¦)

#### ì§‘ê¸° ì‹œìŠ¤í…œ êµ¬í˜„

**1. Sweep ê¸°ë°˜ íƒì§€**
```cpp
void UInteractComponent::GrabProps()
{
    FVector Start = Owner->GetFirstPersonCameraComponent()->GetComponentLocation();
    FVector End = Start + Owner->GetCamera()->GetForwardVector() * GrabDistance;
    
    FCollisionShape Sphere = FCollisionShape::MakeSphere(GrabRadius);
    
    if (GetWorld()->SweepSingleByChannel(Hit, Start, End, ...))
    {
        // WrappingPaper íŠ¹ìˆ˜ ì²˜ë¦¬
        if (AWrappingPaper* wp = Cast<AWrappingPaper>(Hit.GetActor()))
        {
            wp->TryWrap();  // í¬ì¥ ì‹œë„
            return;
        }
        
        // IGrabableProps ì¸í„°í˜ì´ìŠ¤ ì²´í¬
        if (Cast<IGrabableProps>(Hit.GetActor()))
            MulticastRPC_GrabProps(Hit);
            
        // IngContainer íŠ¹ìˆ˜ ì²˜ë¦¬
        else if (AIngContainer* Container = Cast<AIngContainer>(Hit.GetActor()))
        {
            AIngredientBase* Ing = Container->GetIngredient();
            MulticastRPC_InteractIngContainer(Ing);
        }
    }
}
```

**2. ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™”**
```cpp
void UInteractComponent::MulticastRPC_GrabProps_Implementation(FHitResult Hit)
{
    IGrabableProps* GrabInterface = Cast<IGrabableProps>(Hit.GetActor());
    GrabInterface->OnGrabbed(Owner);
    
    // ë¬¼ë¦¬ ë„ê¸°
    Hit.GetComponent()->SetSimulatePhysics(false);
    Hit.GetComponent()->SetCollisionProfileName(TEXT("Grabbed"));
    
    // ì¹´ë©”ë¼ì— ë¶€ì°©
    HoldDistance = FVector::Dist(CameraLocation, ActorLocation);
    HoldDistance = FMath::Clamp(HoldDistance, 50, 200);
    
    Cast<AActor>(GrabInterface)->AttachToComponent(
        Owner->GetFirstPersonCameraComponent(), 
        FAttachmentTransformRules::SnapToTargetNotIncludingScale
    );
    
    GrabInterface->SetLocation(
        CameraLocation + CameraForward * HoldDistance
    );
    
    bIsGrabbed = true;
    GrabbedProp = GrabInterface;
}

// IngredientBaseì˜ OnGrabbed - ë‹¤ë¥¸ í”Œë ˆì´ì–´ê°€ ì§‘ê³  ìˆìœ¼ë©´ ì²˜ë¦¬
void AIngredientBase::OnGrabbed(AMHGACharacter* Player)
{
    if (GrabCharacter != Player && GrabCharacter != nullptr)
    {
        // ì´ì „ì— ì§‘ê³  ìˆë˜ ìºë¦­í„°ê°€ ìˆìœ¼ë©´ ë‚´ë ¤ë†“ê²Œ í•¨
        GrabCharacter->GetInteractComponent()->PutProps();
    }
    GrabCharacter = Player;
}
```

**3. ë‚´ë ¤ë†“ê¸°**
```cpp
void UInteractComponent::PutProps()
{
    if (GrabbedProp)
    {
        GrabbedProp->OnPut();
        
        AActor* P = Cast<AActor>(GrabbedProp);
        if (UPrimitiveComponent* Root = Cast<UPrimitiveComponent>(P->GetRootComponent()))
        {
            // ë¬¼ë¦¬ ë‹¤ì‹œ ì¼œê¸°
            Root->SetSimulatePhysics(true);
            Root->SetCollisionProfileName(TEXT("BlockAllDynamic"));
            P->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);
        }
        
        bIsGrabbed = false;
        GrabbedProp = nullptr;
    }
}
```

#### íŠ¹ìˆ˜ ë„êµ¬: Flipper (ë’¤ì§‘ê°œ)

**íŒ¨í‹° ë’¤ì§‘ê¸° êµ¬í˜„**
```cpp
void AFlipper::OnUse()
{
    FVector Start = GrabCharacter->GetCamera()->GetComponentLocation();
    FVector End = Start + GrabCharacter->GetCamera()->GetForwardVector() * 200;
    
    if (GetWorld()->SweepSingleByChannel(Hit, Start, End, ...))
    {
        if (Hit.GetComponent()->IsSimulatingPhysics())
        {
            // ì¹´ë©”ë¼ì˜ Right ë²¡í„° ê¸°ì¤€ìœ¼ë¡œ 180ë„ íšŒì „
            FRotationMatrix CamMatrix(CameraRotation);
            FVector RightVector = CamMatrix.GetScaledAxis(EAxis::Y);
            
            FQuat CurrentQuat = Hit.GetActor()->GetActorQuat();
            FQuat FlipQuat = FQuat(RightVector, FMath::DegreesToRadians(180.f));
            FQuat NewQuat = FlipQuat * CurrentQuat;
            
            Hit.GetActor()->SetActorRotation(NewQuat);
        }
    }
}
```

#### ì¬ë£Œ ì»¨í…Œì´ë„ˆ ì‹œìŠ¤í…œ

**AIngContainer í´ë˜ìŠ¤**
- ë¬´í•œ ì¬ë£Œ ê³µê¸‰ ì‹œìŠ¤í…œ
- Interact ì‹œ ìƒˆ ì¬ë£Œ ì¸ìŠ¤í„´ìŠ¤ ìŠ¤í°

```cpp
class AIngContainer : public AActor
{
    UPROPERTY(EditAnywhere)
    TSubclassOf<AIngredientBase> Ingredient;
    
    AIngredientBase* GetIngredient()
    {
        return GetWorld()->SpawnActor<AIngredientBase>(Ingredient);
    }
};
```

---

### 7. ìºë¦­í„° ë° ì…ë ¥ ì‹œìŠ¤í…œ

**Enhanced Input System ê¸°ë°˜ì˜ 1ì¸ì¹­ ìºë¦­í„° ì»¨íŠ¸ë¡¤**

#### MHGACharacter êµ¬ì¡°

**ì»´í¬ë„ŒíŠ¸ êµ¬ì„±**
- **UCameraComponent**: 1ì¸ì¹­ ì‹œì  ì¹´ë©”ë¼
  - FirstPersonFieldOfView: 70ë„
  - FirstPersonScale: 0.6 (ì† í¬ê¸° ì¡°ì ˆ)
- **UInteractComponent**: ì˜¤ë¸Œì íŠ¸ ìƒí˜¸ì‘ìš©
- **UWidgetInteractionComponent**: 3D UI ìƒí˜¸ì‘ìš©
- **USkeletalMeshComponent**: 1ì¸ì¹­ ë°”ë”” ë©”ì‹œ

#### Enhanced Input Actions

```cpp
// ì´ë™
IA_Move   : Vector2D (WASD)
// ì‹œì 
IA_Look   : Vector2D (ë§ˆìš°ìŠ¤)
// ì§‘ê¸°/ë†“ê¸°
IA_Pick   : Button (E)
// ì‚¬ìš©
IA_Use    : Button (ë§ˆìš°ìŠ¤ ì¢Œí´ë¦­)
// ì•‰ê¸°
IA_Crouch : Button (Ctrl)
// ê²Œì„ ì‹œì‘ (í˜¸ìŠ¤íŠ¸ë§Œ)
IA_Start  : Button (G) 
// ìŒì„± ì±„íŒ…
IA_Voice  : Button (V - Hold)
// UI ëª¨ë“œ ì „í™˜
IA_UI     : Button (Tab - Hold)
```

**ì…ë ¥ ì²˜ë¦¬ ì˜ˆì‹œ**
```cpp
void AMHGACharacter::PickInput(const FInputActionValue& Value)
{
    if (IsLocallyControlled())
        InteractComponent->ServerRPC_InteractProps();
}

void AMHGACharacter::UseInput(const FInputActionValue& Value)
{
    if (IsLocallyControlled())
    {
        // 3D UI ìƒí˜¸ì‘ìš©
        WidgetInteraction->PressPointerKey(EKeys::LeftMouseButton);
        
        // Props ì‚¬ìš©
        InteractComponent->ServerRPC_UseProps();
    }
}

void AMHGACharacter::StartInput(const FInputActionValue& Value)
{
    if (HasAuthority())  // ì„œë²„(í˜¸ìŠ¤íŠ¸)ì—ì„œë§Œ ì‹¤í–‰
    {
        AMHGAGameMode* gm = Cast<AMHGAGameMode>(UGameplayStatics::GetGameMode(this));
        AMHGAGameState* gs = Cast<AMHGAGameState>(UGameplayStatics::GetGameState(this));
        if (gm && gs && !gs->bIsGamePlaying)
        {
            gm->GameStart();  // ê²Œì„ ì‹œì‘
        }
    }
}

void AMHGACharacter::StartVoiceInput()
{
    AMHGAPlayerController* pc = GetController<AMHGAPlayerController>();
    pc->StartTalking();  // ìŒì„± ì±„íŒ… ì‹œì‘
}

void AMHGACharacter::StartUIInput()
{
    APlayerController* pc = GetWorld()->GetFirstPlayerController();
    UWidgetBlueprintLibrary::SetInputMode_GameAndUIEx(pc);
    pc->SetShowMouseCursor(true);  // ë§ˆìš°ìŠ¤ ì»¤ì„œ í‘œì‹œ
}
```

#### Widget Interaction êµ¬ì„±

**3D POS ì‹œìŠ¤í…œ ìƒí˜¸ì‘ìš©**
```cpp
WidgetInteraction = CreateDefaultSubobject<UWidgetInteractionComponent>(...);
WidgetInteraction->SetupAttachment(FPSCamComponent);
WidgetInteraction->InteractionDistance = 200.f;
WidgetInteraction->bShowDebug = true;  // ë””ë²„ê·¸ ë¼ì¸ í‘œì‹œ
```

**ë™ì‘ ë°©ì‹**
1. ì¹´ë©”ë¼ ì¤‘ì•™ì—ì„œ Ray ë°œì‚¬
2. Widget Componentì™€ ì¶©ëŒ ì‹œ í´ë¦­ ì´ë²¤íŠ¸ ì „ë‹¬
3. ë¡œì»¬ í”Œë ˆì´ì–´ì—ì„œë§Œ í™œì„±í™”

#### ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œ (PlayerAnim)

**Blend Space ê¸°ë°˜ ì´ë™ ì• ë‹ˆë©”ì´ì…˜**
```cpp
class UPlayerAnim : public UAnimInstance
{
    UPROPERTY(BlueprintReadOnly)
    float Speed = 0;      // ì „ì§„/í›„ì§„ ì†ë„
    
    UPROPERTY(BlueprintReadOnly)
    float Dir = 0;        // ì¢Œìš° ì´ë™
    
    UPROPERTY(BlueprintReadOnly)
    float CameraRotX = 0; // ì¹´ë©”ë¼ ìƒí•˜ íšŒì „
    
    UPROPERTY(BlueprintReadOnly)
    bool bIsCrouch = false;
};
```

**ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸**
```cpp
void UPlayerAnim::NativeUpdateAnimation(float DeltaSeconds)
{
    if (OwnerPlayer)
    {
        // ì „í›„ ì´ë™ ì†ë„ (ì •ê·œí™”)
        Speed = FVector::DotProduct(
            OwnerPlayer->GetVelocity(), 
            OwnerPlayer->GetActorForwardVector()
        ) / OwnerPlayer->GetCharacterMovement()->GetMaxSpeed();
        
        // ì¢Œìš° ì´ë™ ì†ë„ (ì •ê·œí™”)
        Dir = FVector::DotProduct(
            OwnerPlayer->GetVelocity(), 
            OwnerPlayer->GetActorRightVector()
        ) / OwnerPlayer->GetCharacterMovement()->GetMaxSpeed();
        
        // ì¹´ë©”ë¼ í”¼ì¹˜
        CameraRotX = -OwnerPlayer->GetBaseAimRotation().Pitch;
        
        // ì•‰ê¸° ìƒíƒœ
        bIsCrouch = OwnerPlayer->GetCharacterMovement()->IsCrouching();
    }
}
```

---

## ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```mermaid
graph TB
    subgraph "Network Layer"
        NET["ğŸ”„ Listen Server<br/>RPC & Replication"]
    end

    subgraph "Game Logic"
        AI["ğŸ¤– FSM-based AI<br/>Customer System"]
        COOK["ğŸ³ Cooking System<br/>State Machine"]
        POS["ğŸ’³ POS System<br/>Order Management"]
    end

    subgraph "Player Interaction"
        INTERACT["âœ‹ Interact Component<br/>Physics-based Grab"]
        INPUT["âŒ¨ï¸ Enhanced Input<br/>Action-based Control"]
    end

    subgraph "Data Management"
        DATATABLE["ğŸ“Š DataTable<br/>Recipe System"]
        GAMESTATE["ğŸ“ˆ GameState<br/>Score Management"]
    end

    NET --> AI
    NET --> COOK
    NET --> POS
    INPUT --> INTERACT
    DATATABLE --> COOK
    DATATABLE --> POS
    GAMESTATE --> POS
    INTERACT --> COOK

    style NET fill:#87CEEB
    style AI fill:#DDA0DD
    style COOK fill:#F0E68C
    style POS fill:#FFB6C1
    style INTERACT fill:#98FB98
    style INPUT fill:#90EE90
    style DATATABLE fill:#FFE4B5
    style GAMESTATE fill:#FFE4B5
```

## ì£¼ìš” ê¸°ìˆ  í¬ì¸íŠ¸

| ì¹´í…Œê³ ë¦¬ | ê¸°ìˆ  | íŠ¹ì§• |
|---------|------|------|
| **ë„¤íŠ¸ì›Œí¬** | Listen Server + RPC | ë©€í‹°í”Œë ˆì´ì–´ ë™ê¸°í™” |
| **AI** | FSM (9ê°€ì§€ ìƒíƒœ) | ì§€ëŠ¥í˜• ì†ë‹˜ í–‰ë™ |
| **ë¬¼ë¦¬** | Physics-based Grab | ì‹¤ê°ìˆëŠ” ìƒí˜¸ì‘ìš© |
| **UI** | Widget Component 3D | ëª°ì…í˜• POS ì‹œìŠ¤í…œ |
| **ë°ì´í„°** | DataTable ê¸°ë°˜ | í™•ì¥ ê°€ëŠ¥í•œ ë ˆì‹œí”¼ ê´€ë¦¬ |
| **ê²Œì„í”Œë ˆì´** | ìƒíƒœ ë¨¸ì‹  ì¡°ë¦¬ | íƒ€ì´ë° ê¸°ë°˜ ê²Œì„ ë©”ì»¤ë‹ˆì¦˜ |

---

## ğŸ¯ Tech Highlights

### 1. ë°ì´í„° ì£¼ë„ ì„¤ê³„ (Data-Driven Design)

**DataTableì„ í™œìš©í•œ ë ˆì‹œí”¼ ê´€ë¦¬**

```cpp
// BurgerData.h
USTRUCT(BlueprintType)
struct FBurgerRecipe : public FTableRowBase
{
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    EBurgerMenu BurgerName;
    
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TArray<FIngredientStack> Ingredients;
};
```

**ì¥ì **
- í”„ë¡œê·¸ë˜ë¨¸ ì—†ì´ ë””ìì´ë„ˆê°€ ë©”ë‰´ ì¶”ê°€/ìˆ˜ì • ê°€ëŠ¥
- í™•ì¥ì„± (ì‹ ê·œ ë©”ë‰´ ì¶”ê°€ ìš©ì´)

### 2. ë„¤íŠ¸ì›Œí¬ ì„¤ê³„

**RPC í˜¸ì¶œ ì²´ì¸ ìµœì í™”**
```
Client Input 
â†’ ServerRPC (PlayerController) 
â†’ MulticastRPC (Counter Actor) 
â†’ All Clients Update UI
```

**ì´ì **
- ì„œë²„ì—ì„œ ë°ì´í„° ê²€ì¦
- ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ìë™ ë™ê¸°í™”
- í´ë¼ì´ì–¸íŠ¸ ê°„ ë¶ˆì¼ì¹˜ ë°©ì§€

### 3. FSM ê¸°ë°˜ AI ì„¤ê³„

**ìƒíƒœ ì „í™˜ ë¡œì§**
```cpp
void UCustomerFSM::SetState(EAIState NewState)
{
    if (CurrentState == NewState) return;
    
    StopWandering();
    CurrentState = NewState;
    
    switch (CurrentState)
    {
    case EAIState::GoingToLine:
        MoveToTarget(orderTarget);
        break;
    case EAIState::Ordering:
        StartOrder();
        break;
    // ...
    }
}
```

**ì¥ì **
- ë””ë²„ê¹… ìš©ì´
- ìƒíƒœ ì¶”ê°€/ìˆ˜ì • ê°„ë‹¨
- ëª…í™•í•œ í–‰ë™ íŒ¨í„´

### 4. ì»´í¬ë„ŒíŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜

**ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸ ì„¤ê³„**
- InteractComponent: ëª¨ë“  ìƒí˜¸ì‘ìš© í†µí•© ê´€ë¦¬
- CustomerFSM: AI í–‰ë™ ë¡œì§ ë¶„ë¦¬
- WidgetInteraction: 3D UI ìƒí˜¸ì‘ìš©

### 5. ë¬¼ë¦¬ ê¸°ë°˜ ê²Œì„í”Œë ˆì´

**ë¦¬ì–¼ë¦¬ì¦˜ì„ ìœ„í•œ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜**
- ëª¨ë“  ì¬ë£ŒëŠ” ì‹¤ì œ ë¬¼ë¦¬ ë²•ì¹™ ì ìš©
- ì§‘ê¸°/ë†“ê¸° ì‹œ ë¬¼ë¦¬ on/off ì „í™˜
- ì˜ìˆ˜ì¦, í–„ë²„ê±° ë“± ì™„ì„±í’ˆë„ ë¬¼ë¦¬ ì ìš©

---

## ğŸ”§ ì‚¬ìš© ê¸°ìˆ  ìŠ¤íƒ

### ì—”ì§„ ë° ì–¸ì–´

```mermaid
graph LR
    A["Unreal Engine 5.6"] --> B["C++<br/>í•µì‹¬ ë¡œì§"]
    A --> C["Blueprint<br/>UI/Level"]

    style A fill:#000000,color:#fff,stroke:#FFD700,stroke-width:3px
    style B fill:#87CEEB
    style C fill:#DDA0DD
```

### Unreal Engine ëª¨ë“ˆ (Dependencies)

```mermaid
graph TD
    subgraph "Foundation"
        F1["Core"]
        F2["CoreUObject"]
        F3["Engine"]
    end

    subgraph "Input & Control"
        I1["InputCore"]
        I2["EnhancedInput<br/>Input Actions"]
    end

    subgraph "AI & Navigation"
        A1["AIModule"]
        A2["NavigationSystem<br/>NavMesh"]
        A3["StateTreeModule"]
    end

    subgraph "UI & Graphics"
        U1["UMG<br/>Widget System"]
        U2["Slate<br/>Framework"]
    end

    F1 --> F2
    F2 --> F3
    F3 --> I1
    I1 --> I2
    F3 --> A1
    A1 --> A2
    A2 --> A3
    F3 --> U1
    U1 --> U2

    style F1 fill:#90EE90
    style F2 fill:#90EE90
    style F3 fill:#90EE90
    style I1 fill:#87CEEB
    style I2 fill:#87CEEB
    style A1 fill:#FFB6C1
    style A2 fill:#FFB6C1
    style A3 fill:#FFB6C1
    style U1 fill:#FFE4B5
    style U2 fill:#FFE4B5
```

**ì£¼ìš” ëª¨ë“ˆë³„ ì—­í• **

| ëª¨ë“ˆ | ìš©ë„ |
|------|------|
| **EnhancedInput** | Input Action ê¸°ë°˜ ì…ë ¥ ì²˜ë¦¬, ìƒí™©ë³„ ì…ë ¥ ì „í™˜ |
| **AIModule** | AI ì´ë™ ë° í–‰ë™ ì œì–´ |
| **NavigationSystem** | NavMesh ê¸°ë°˜ ê²½ë¡œ íƒìƒ‰, ë°°íšŒ êµ¬í˜„ |
| **StateTreeModule** | ìƒíƒœ ë¨¸ì‹  ë° í–‰ë™ íŠ¸ë¦¬ |
| **UMG** | 3D Widget Component, ì£¼ë¬¸ UI, ì†ë‹˜ ë§í’ì„  |
| **Slate** | ë¡œìš°ë ˆë²¨ UI í”„ë ˆì„ì›Œí¬ |

### í•µì‹¬ ê¸°ìˆ  ì ìš©

```mermaid
graph TB
    subgraph "Network"
        N1["Listen Server"]
        N2["RPC System"]
        N3["Replication"]
    end

    subgraph "AI & Behavior"
        AI1["FSM<br/>9ê°œ ìƒíƒœ"]
        AI2["NavMesh ì´ë™"]
        AI3["íƒ€ì´ë¨¸ ê¸°ë°˜<br/>ë°°íšŒ"]
    end

    subgraph "Physics & Interaction"
        P1["Physics Simulation"]
        P2["Sweep Collision"]
        P3["Grab/Release"]
    end

    subgraph "Data Driven"
        D1["DataTable<br/>ë ˆì‹œí”¼"]
        D2["Configuration"]
        D3["Dynamic Loading"]
    end

    N1 --> N2
    N2 --> N3
    AI1 --> AI2
    AI2 --> AI3
    P1 --> P2
    P2 --> P3
    D1 --> D2
    D2 --> D3

    N1 -.-> AI1
    N1 -.-> P1
    N1 -.-> D1

    style N1 fill:#87CEEB,stroke:#0066cc,stroke-width:2px
    style N2 fill:#87CEEB
    style N3 fill:#87CEEB
    style AI1 fill:#DDA0DD,stroke:#990099,stroke-width:2px
    style AI2 fill:#DDA0DD
    style AI3 fill:#DDA0DD
    style P1 fill:#98FB98,stroke:#006600,stroke-width:2px
    style P2 fill:#98FB98
    style P3 fill:#98FB98
    style D1 fill:#FFE4B5,stroke:#FF6600,stroke-width:2px
    style D2 fill:#FFE4B5
    style D3 fill:#FFE4B5
```

---

## ğŸ® ê²Œì„ í”Œë¡œìš° ë° ì‹œë‚˜ë¦¬ì˜¤

### ì „ì²´ ê²Œì„ ì‚¬ì´í´

```mermaid
sequenceDiagram
    participant P1 as í”Œë ˆì´ì–´ 1<br/>Host
    participant P2 as í”Œë ˆì´ì–´ 2<br/>Client
    participant Server as GameMode<br/>Server Logic
    participant Customer as AI ì†ë‹˜
    participant UI as POS UI

    Note over P1,P2: [ê²Œì„ ì‹œì‘]
    P1->>Server: Gí‚¤ ëˆ„ë¦„ (GameStart)
    Server->>Server: íƒ€ì´ë¨¸ ì‹œì‘ (5ë¶„)
    Server->>Customer: ì†ë‹˜ ìŠ¤í° ì‹œì‘

    Note over P1,P2: [ì£¼ë¬¸ ì ‘ìˆ˜]
    Customer->>UI: ì¹´ìš´í„° ë„ì°©
    P1->>UI: ë©”ë‰´ ì„ íƒ
    UI->>Server: ServerRPC_AddMenu
    Server->>UI: MulticastRPC ë™ê¸°í™”
    P1->>UI: ì£¼ë¬¸ ë²„íŠ¼

    Note over P1,P2: [ì¡°ë¦¬]
    P1->>Server: ì¬ë£Œ ì§‘ê¸°
    P1->>Server: ì¡°ë¦¬ ì˜ì—­ì— ë°°ì¹˜
    Server->>Server: ì¡°ë¦¬ íƒ€ì´ë¨¸<br/>0sâ†’3sâ†’8s

    Note over P1,P2: [í¬ì¥]
    P2->>UI: í¬ì¥ì§€ì— ì¬ë£Œ ë°°ì¹˜
    UI->>Server: ë ˆì‹œí”¼ ë§¤ì¹­
    Server->>Server: í–„ë²„ê±° ìƒì„±

    Note over P1,P2: [í”½ì—…]
    Customer->>UI: í”½ì—… ì¡´ìœ¼ë¡œ ì´ë™
    Customer->>Server: ìŒì‹ ê²€ì¦
    Server->>Server: ì ìˆ˜ ì—…ë°ì´íŠ¸
    Customer->>Customer: í‡´ì¥

    Note over P1,P2: [ê²Œì„ ì¢…ë£Œ]
    Server->>Server: íƒ€ì„ ì˜¤ë²„
    Server->>UI: ìµœì¢… ì ìˆ˜ í‘œì‹œ
    Server->>P1: ë¡œë¹„ë¡œ ì´ë™
    Server->>P2: ë¡œë¹„ë¡œ ì´ë™
```

### ê²Œì„ ìƒíƒœ ë¨¸ì‹ 

```mermaid
graph TD
    A["ğŸ  ë¡œë¹„<br/>Lobby"] -->|Ready í´ë¦­| B["â³ ë¡œë”©<br/>Loading"]
    B -->|ë ˆë²¨ ë¡œë“œ ì™„ë£Œ| C["ğŸ® ê²Œì„ í”Œë ˆì´<br/>Playing"]
    C -->|íƒ€ì´ë¨¸ ì¢…ë£Œ| D["ğŸ“Š ê²Œì„ ì˜¤ë²„<br/>GameOver"]
    D -->|10ì´ˆ ëŒ€ê¸°| A

    C -.->|ì¼ì‹œì •ì§€ ESC| C

    style A fill:#90EE90
    style B fill:#87CEEB
    style C fill:#FFE4B5
    style D fill:#FFB6C1
```

---

## ğŸ“Š ì„±ëŠ¥ ìµœì í™”

### 1. ë„¤íŠ¸ì›Œí¬ ìµœì í™”
- **Authority ì²´í¬**: ì„œë²„ì—ì„œë§Œ ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” ë¡œì§ ë¶„ë¦¬
- **ì„ íƒì  ë³µì œ**: í•„ìš”í•œ ë°ì´í„°ë§Œ ë³µì œ
- **RPC ìµœì†Œí™”**: ì—¬ëŸ¬ í´ë¼ì´ì–¸íŠ¸ í˜¸ì¶œì„ í•˜ë‚˜ì˜ Multicastë¡œ í†µí•©

### 2. AI ìµœì í™”
- **íƒ€ì´ë¨¸ ê¸°ë°˜ ì—…ë°ì´íŠ¸**: Tick ëŒ€ì‹  íƒ€ì´ë¨¸ë¡œ ë°°íšŒ ë¡œì§ ì²˜ë¦¬
- **NavMesh ìºì‹±**: ì´ë™ ê²½ë¡œ ì¬ê³„ì‚° ìµœì†Œí™”

### 3. ë¬¼ë¦¬ ìµœì í™”
- **Collision Profile í™œìš©**: ìƒí™©ì— ë§ëŠ” ì¶©ëŒ ì„¤ì •
- **Physics Sleep**: ì •ì§€ ì‹œ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì§€

---

## ğŸš€ í–¥í›„ ê°œì„  ë°©í–¥

### ê³„íšëœ ê¸°ëŠ¥
- [x] **í‰íŒ ì‹œìŠ¤í…œ**: ì†ë‹˜ ë§Œì¡±ë„ì— ë”°ë¥¸ ì ìˆ˜ ê´€ë¦¬ (ShowScoreFeedback í•¨ìˆ˜ë¡œ êµ¬í˜„ë¨)
- [x] **ë‚œì´ë„ ì¡°ì ˆ**: ì†ë‹˜ ìŠ¤í° ë¹ˆë„, ì£¼ë¬¸ ë³µì¡ë„ ì¡°ì ˆ (MaxSpawnedCustomers ë³€ìˆ˜ ì¡´ì¬)
- [ ] **ì¶”ê°€ ë©”ë‰´**: ì‚¬ì´ë“œ ë©”ë‰´, ìŒë£Œ ì‹œìŠ¤í…œ
- [ ] **ì‹œê°„ ì œí•œ ëª¨ë“œ**: ì œí•œ ì‹œê°„ ë‚´ ìµœëŒ€í•œ ë§ì€ ì£¼ë¬¸ ì²˜ë¦¬

---

## ğŸ“ ì½”ë“œ êµ¬ì¡°

```
Source/MHGA/
â”œâ”€â”€ Public/
â”‚   â”œâ”€â”€ AI/
â”‚   â”‚   â”œâ”€â”€ CustomerAI.h          # ì†ë‹˜ ìºë¦­í„°
â”‚   â”‚   â”œâ”€â”€ CustomerFSM.h         # ì†ë‹˜ FSM
â”‚   â”‚   â”œâ”€â”€ CustomerManager.h    # ì†ë‹˜ ìƒì„±/ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ CustomerUI.h          # ì†ë‹˜ UI
â”‚   â”œâ”€â”€ Counter/
â”‚   â”‚   â”œâ”€â”€ CounterPOS.h          # POS ì‹œìŠ¤í…œ
â”‚   â”‚   â”œâ”€â”€ CounterUI.h           # POS UI
â”‚   â”‚   â”œâ”€â”€ MenuButtonUI.h        # ë©”ë‰´ ë²„íŠ¼
â”‚   â”‚   â”œâ”€â”€ CustomerButtonUI.h   # ì£¼ë¬¸ ë²„íŠ¼
â”‚   â”‚   â”œâ”€â”€ PickupZone.h          # í”½ì—… êµ¬ì—­
â”‚   â”‚   â””â”€â”€ ReceiptActor.h        # ì˜ìˆ˜ì¦
â”‚   â”œâ”€â”€ Ingredient/
â”‚   â”‚   â”œâ”€â”€ IngredientBase.h      # ì¬ë£Œ ë² ì´ìŠ¤ í´ë˜ìŠ¤
â”‚   â”‚   â”œâ”€â”€ Patty.h               # íŒ¨í‹° (ì¡°ë¦¬ ìƒíƒœ)
â”‚   â”‚   â”œâ”€â”€ SauceBottle.h         # ì†ŒìŠ¤ ë³‘
â”‚   â”‚   â””â”€â”€ [ê¸°íƒ€ ì¬ë£Œë“¤]
â”‚   â”œâ”€â”€ Player/
â”‚   â”‚   â”œâ”€â”€ MHGACharacter.h       # í”Œë ˆì´ì–´ ìºë¦­í„°
â”‚   â”‚   â”œâ”€â”€ MHGAPlayerController.h# í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬
â”‚   â”‚   â”œâ”€â”€ InteractComponent.h   # ìƒí˜¸ì‘ìš© ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â””â”€â”€ PlayerAnim.h          # ì• ë‹ˆë©”ì´ì…˜
â”‚   â”œâ”€â”€ Props/
â”‚   â”‚   â”œâ”€â”€ Flipper.h             # ë’¤ì§‘ê°œ
â”‚   â”‚   â””â”€â”€ IngContainer.h        # ì¬ë£Œ ì»¨í…Œì´ë„ˆ
â”‚   â”œâ”€â”€ BurgerData.h              # ë°ì´í„° ì •ì˜
â”‚   â”œâ”€â”€ CookingArea.h             # ì¡°ë¦¬ ì˜ì—­
â”‚   â”œâ”€â”€ GrabableProps.h           # ìƒí˜¸ì‘ìš© ì¸í„°í˜ì´ìŠ¤
â”‚   â”œâ”€â”€ Hamburger.h               # ì™„ì„±ëœ í–„ë²„ê±°
â”‚   â”œâ”€â”€ WrappingPaper.h           # í¬ì¥ì§€
â”‚   â”œâ”€â”€ MHGAGameMode.h            # ê²Œì„ ëª¨ë“œ
â”‚   â””â”€â”€ MHGAGameState.h           # ê²Œì„ ìŠ¤í…Œì´íŠ¸
â””â”€â”€ Private/
    â””â”€â”€ [ëŒ€ì‘ë˜ëŠ” .cpp íŒŒì¼ë“¤]
```

---

## Members
- ê¹€í™ë²”
- í™©ê·œí™˜
- í—ˆì§€ì›…


---

## ğŸ“œ ë¼ì´ì„ ìŠ¤

Copyright Epic Games, Inc. All Rights Reserved.

---

### ì£¼ìš” ì„±ê³¼

| ì˜ì—­ | ì„±ê³¼ | ê¸°ìˆ  |
|------|------|------|
| **ë„¤íŠ¸ì›Œí¬** | Listen Server ë©€í‹°í”Œë ˆì´ êµ¬í˜„ | RPC Chain, Replication |
| **AI** | 9ê°€ì§€ ìƒíƒœì˜ FSM ê¸°ë°˜ ì†ë‹˜ AI | NavMesh, State Management |
| **ê²Œì„í”Œë ˆì´** | ë¬¼ë¦¬ ê¸°ë°˜ ìƒí˜¸ì‘ìš© ì‹œìŠ¤í…œ | Physics Grab/Release, Collision |
| **UI/UX** | 3D ëª°ì…í˜• POS ì‹œìŠ¤í…œ | Widget Component, Canvas |
| **ë°ì´í„°** | í™•ì¥ ê°€ëŠ¥í•œ ë ˆì‹œí”¼ ê´€ë¦¬ | DataTable, JSON ì„¤ì • |
| **ì„±ëŠ¥** | ìµœì í™”ëœ ë„¤íŠ¸ì›Œí¬ ì„¤ê³„ | Authority Check, Selective Replication |



**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2025ë…„ 11ì›” 8ì¼
